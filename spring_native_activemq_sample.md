# Problem 1: Fork Spring Native and Add an ActiveMQ Sample

For this problem, I added a new sample application to the `spring-native`
project, `samples/activemq`, and I added two new `NativeConfiguration`s to the
`spring-native-configuration` Maven artifact, `JmsHints` and `ActiveMQHints`
which support this sample.

I made these modifications on the `[main]` branch of [my GitHub fork of
`spring-native`][dwtj-fork].

In overview, I performed these steps:

1. Skimmed [Issue #438][issue-438] for some context and pointers.
2. Briefly researched relevant technologies which I haven't worked with before:
JMS, Spring Framework, Spring Boot, Spring Native, Spring AOT, Spring JMS,
ActiveMQ, and the GraalVM `native-image` tracing agent.
3. Researched some details of technologies which I have used before, especially
Maven and GraalVM `native-image` configuration.
4. Studied some of the `spring-native` project's organization and existing
samples to understand how and where my additions should be inserted.
5. Drafted the `samples/activemq` Spring Boot application.
6. Used the GraalVM `native-image` tracing agent on the executable JAR of
`samples/activemq` to generate `native-image` configuration files (e.g.
`reflect-config.json`).
7. Filtered out much of the redundant `native-image` configuration generated by
the tracing agent by trial-and-error based on class package names.
8. Replaced some of the traced native configuration with a `@NativeHint` on my
`activemq` sample's `@SpringBootApplication` class to start experimenting with
Spring AOT's native hints feature.
9. Replaced some of the traced native configuration with a first draft
`NativeConfiguration` in `spring-native-configuration`. It is named
`org.springframework.jms.JmsHints`.
10. Move other traced native configuration into `NativeConfiguration`s.
11. I tested my Spring Native modifications on a few different development
platforms.
12. Finally, I drafted this document.

In this document, I will describe how I performed these modifications.

## Steps 1-3. My Background and Background Reserch

Before this project, I had not used a number of relevant technologies. In
particular, I had not used any part of the Spring project. I only had a vague
notion that it was a framework that provided lots of useful integrations,
features, and "magic". In fact, I didn't even understand its role as an
Inversion of Control (a.k.a., dependency injection) framework, nor did I know
about its dependency management features.

On my first skim of the homework prompt and [Issue #438][issue-438], there were
lots of concepts and terms which I didn't understand. Fortunately, I at least
had some experience with writing a little bit of GraalVM `native-image`
configuration (e.g., `reflect-config.json`), so I understood the motivation
behind Spring Native and Spring AOT.

So, my first step was to familiarize myself with a number of relevant
technologies, including

- JMS
- Spring Framework
- Spring Boot
- Spring JMS
- ActiveMQ
- Spring Native
- Spring AOT
- GraalVM `native-image` tracing agent

Fortunately, I easily found lots of good documentation on these technologies.

I spent one day studying this background information.

Throughout all stages of the project, I often went back and reviewed various
reference materials as needed.

I found the [Spring Native documentation][spring-native-ref] to be excellent. I
came back to this document quite a few times. There were very useful
explanations and advice in there which I did not understand at first. It was
only after diving into this problem and reading the project's source code that I
was able to understand some of it. It was an excellent resource, and it helped
me greatly throughout this process.

I still don't understand very much about Spring. I did not research any details
of how Spring integrates ActiveMQ and JMS. They seemed too complicated and
unfamiliar to study in the time allotted, one week. I instead chose to treat my
`sample/activemq` application as a black box. As I describe later, this choice
to treat my application as a black box worked, though the resulting
trial-and-error process was somewhat tedious, and the resulting native hints are
likely brittle.

## Steps 4-5. Add a Spring Boot ActiveMQ Sample

I added a new sample Spring Boot application, `samples/activemq`.

Before adding a sample application to the project, I started by reading the
pre-existing samples in order to look for the style and organization that they
use. Because the project as a whole is based around Maven, I chose to build my
sample with Maven and to follow standard Maven file system conventions.

Like other Maven-based samples that I read, `samples/activemq`

- Selects `samples/maven-parent` as its parent to help configure some
boilerplate.
- Has a `build.sh` script which delegates to `scripts/compileWithMaven.sh`
(which actually builds *and* tests the Maven project).
- Has a `verify.sh` script which checks the test output for some correctness
properties. In my case, I am just checking to see that the message sent across ActiveMQ is printed as expected.

The Spring Boot application itself is a slightly simplified version of the
application from the [Messaging with JMS][messaging-with-jms] Spring Guide.
This application is based on the `spring-boot-starter-activemq` starter.

I believe that `samples/activemq` uses an embedded ActiveMQ broker instance as a
JMS provider. (Presumably, this is "Classic" ActiveMQ, not "Artemis".) I suspect
that different native configuration will be needed for interacting with a
non-embedded ActiveMQ broker. Thus, for future work, a separate sample, say,
`samples/activemq-non-embedded`, should be drafted. This could follow the
example of samples like `rabbitmq` and use `docker-compose` to set up
an integration test with an instance of an ActiveMQ service.

At this point, commit `ae24ee0`, my sample application could be successfully run
with `mvn package spring-boot:run` (i.e., my "Hello, World" message is
sent and received). It took me a day to familiarize myself with the
`spring-native` project and to draft this application (my first Spring
application ever).

However, the integration test triggered by `build.sh` did not yet work. When
running the `native-image`-compiled application, I would get an obscure error
about missing reflection configuration ("No value method found"), with no hints
about what reflective lookup failed.

These errors look something like this:

```
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.
2021-08-05 17:35:27.919 ERROR 15388 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   :

***************************
APPLICATION FAILED TO START
***************************

Description:

Native reflection configuration for No value method found is missing.

Action:

Native configuration for a method accessed reflectively is likely missing.
You can try to configure native hints in order to specify it explicitly.
See https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#native-hints for more details.
```

I would see this error many more times over the next few days.

This error log advised me, "re-run your application with 'debug' enabled".
However, I did not use this throughout my development process. Maybe it would
have made things easier and decreased some of my guess-and-check. However, I
just tried this by running `samples/activemq/target/activemq --debug`, and the
additional error information doesn't seem very informative:

```
java.lang.NoSuchMethodException: No value method found
        at org.springframework.core.annotation.RepeatableContainers$ExplicitRepeatableContainer.<init>(RepeatableContainers.java:203) ~[na:na]
        at org.springframework.core.annotation.RepeatableContainers.of(RepeatableContainers.java:117) ~[na:na]
        at org.springframework.core.annotation.AnnotatedElementUtils.getRepeatableAnnotations(AnnotatedElementUtils.java:759) ~[na:na]
        at org.springframework.core.annotation.AnnotatedElementUtils.getMergedRepeatableAnnotations(AnnotatedElementUtils.java:455) ~[na:na]
        at org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.lambda$postProcessAfterInitialization$0(JmsListenerAnnotationBeanPostProcessor.java:236) ~[activemq:5.3.9]
        at org.springframework.core.MethodIntrospector.lambda$selectMethods$0(MethodIntrospector.java:74) ~[na:na]
        at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:364) ~[na:na]
        at org.springframework.core.MethodIntrospector.selectMethods(MethodIntrospector.java:72) ~[na:na]
        at org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor.postProcessAfterInitialization(JmsListenerAnnotationBeanPostProcessor.java:234) ~[activemq:5.3.9]
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:437) ~[na:na]
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1790) ~[na:na]
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602) ~[na:na]
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[na:na]
        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[na:na]
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[na:na]
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[na:na]
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[na:na]
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) ~[na:na]
        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) ~[na:na]
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[na:na]
        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[activemq:2.5.3]
        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[activemq:2.5.3]
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[activemq:2.5.3]
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[activemq:2.5.3]
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[activemq:2.5.3]
        at com.example.activemq.Application.main(Application.java:45) ~[activemq:0.0.1-SNAPSHOT]
```

Is there a way to get more information about what reflective lookup actually
failed?

## Steps 6-7. Get and Filter Initial Native Configuration

So, as of commit `ae24ee0`, my Spring Boot application was running on the JVM,
but not as a `native-image` because of missing native configuration,
particularly, classes which need reflective access at runtime.

For expediency, I wanted to treat my application (and its use of Spring and
ActiveMQ and JMS) as a black box. I'm not reasonably able to reason about what
is needed from first principles or by reading Spring source code. My error
messages weren't giving me hints about what configuration was missing. So, to
find all necessary native configuration, I used the [GraalVM `native-image`
tracing agent][tracing-agent] while running the application's executable JAR
(`target/activemq-0.0.1-SNAPSHOT-exec.jar`). This generated a set of
`native-image` JSON configuration files.

Most of the native configuration in these files was redundant, since most of it
is already created by Spring AOT to handle other programs. Essentially, I wanted
to know what subset of the necessary configuration observed by the tracing agent
is not already handled by Spring AOT.

With some trial-and-error, I found that only two of these files were needed:
`proxy-config.json` and `reflect-config.json`. By inspecting package names, some
intuition, and some more trial-and-error, I was able to winnow these down to two
lines in the `proxy-config.json` file and four packages of
`reflect-config.json`. The build & test cycles were about 2 minutes long, which
became a bit tedious, but the whole process only took about an hour.

The outputs of the tracing agent can be seen in commit `eba1537`, and my initial
work to filter this configuration can be seen in the next commit, `34da9a0`.

In retrospect, there is a much better way to do this: just look at the textual
(diff) or structural (parsed) differences between the configuration files
generated by the agent and the configuration files generated by Spring AOT. I
think that at the time I hadn't yet realized that Spring AOT generates similar
files under `target/generated-sources/`. It was only at some later point that I
realized that Spring AOT was probably doing something like this and went looking
for it.

If this is an appropriate workflow, maybe the "Tracing Agent" chapter of the
Spring Native manual could include a section pointing out a workflow like this.
It seems like it may be a relevant technique even for Spring Native application
developers (not just Spring Native contributors).

[Section 11.5.1: Comparing Images][spring-native-ref-11-5-1] of the Spring
Native reference gives some advice on comparing two `native-image`-compiled
applications. It seems like comparing the native images themselves may have some
advantages, but is also one step removed from thinking in terms of individual
native configuration items.


## Step 8. Move Native Configuration into an Application-Local `@NativeHint`

After reading the advice from the Spring Native manual, the `@NativeHint`
javadoc, and some examples in `spring-native-configuration`, I wrote my first
`@NativeHint` annotation on my `@SpringBootApplication`. See commit `cfdb3a05`.

This simple `@NativeHint` adds the two pieces of Java [dynamic proxy
class][dynamic-proxy-classes] native configuration needed by `samples/activemq`.

Dynamic proxy classes are actually a Java platform feature that I wasn't
previously familiar with. I still have some uncertainty about how they are used,
but my native configuration seems to work.

## Step 9. Draft First `NativeConfiguration`: `JmsHints`

Of course, the problem prompt asked me to add support to Spring Native itself.
We want to minimize the native-configuration-burden on our users. So, my next
step was to move this `@NativeHint` out of the application and onto something
in Spring Native itself.

This step of my work, commit `dea5eed`, is probably the most important: get
some generally useful configuration logic into Spring Native itself. It was also
maybe the most frustrating (possibly because of a service load ordering bug, as
I will explain below).

["Contributing New Hints"][spring-native-ref-11-2] section of the
Spring Native reference and browsing the source code related to
`NativeConfiguration` in `spring-native-configuration` and `spring-aot` helped
point me in the right direction. (Note that the Spring Native reference appears
to have some typos in this section. The `NativeConfiguration` service's package
is sometimes wrong: it is in the `type` package not the `extension` package.)

Essentially, I need to define a new `NativeConfiguration` service, `JmsHints` in
`spring-native-configuration` annotated with the `@NativeHint` that I drafted in
the section above.

My `JmsHints` service then gets used via this dependency chain:

- My `JmsHints` service is loaded from the Spring AOT library.
- Spring AOT is used as the core of the Spring AOT Maven (or Gradle) Plugin.
- This build plugin is part of the build process for application code.

In the context of my sample application, `samples/activemq`, the goal is to
generate additional native configuration items within
`samples/activemq/target/generated-sources`. I found that my development cycle
was more responsive and comfortable by leaving out the lengthy `native-image`
build step. Instead, I just cycled between

1. Making file changes to `spring-native-configuration`
2. Rebuilding with `mvn install` from within `spring-native-configuration/`.
3. Rebuilding `samples/activemq` with `mvn package` (or `mvn package -X` for
debug logging)
4. `grep`-ing or reading the relevant generated sources.

(Note that, before this would work, I needed to bump the version of
the Maven plugin used by my sample, or more specifically, by all samples using
the `maven-parent`. See commit `ac562d33`. I feel a bit awkward about making
such a change to samples other than my own. I wasn't sure if the lagging version
here was an oversight after the recent v0.10.2 release, or if I'm just missing
something.)

However, I ran into a problem: `JmsHints`'s changes were not having any effect.
In fact, the presence of `JmsHints` was not even being logged by Spring AOT
[here][spring-aot-debug-log-line].

I checked and rechecked the appropriate `META-INF/services` file (the usual
culprit). But once I was sure that it wasn't that, I then tried modifying Spring
AOT itself to see whether it could load `JmsHints`. It turns out it could. The
problem seems to be where `JmsHints` was placed within the list of services!
Somehow, the `for`-loop iterating over all of the loaded `NativeConfiguration`
services was missing mine. From the body of this `for`-loop, it isn't obvious to
me how this is happening. Presumably some sort of exception is being thrown out
of this context. Are other `NativeConfiguration` services being skipped too?

I'll leave this problem to someone else. For now, I just did the easiest thing
that I could think of: I put my service at the beginning of this list. That
actually worked.

Once I was able to add a `@NativeHint` from `spring-native-configuration`
(`dea5eed`), I then added a simple condition to only conditionally enable this
hint (`857434e`).

## Step 10. Move Remaining Reflection Classes into `NativeConfiguration`s

Finishing my draft just involved iteratively adding various reflection
configuration as `@NativeHint`s into `JmsHints` and another new
`NativeConfiguration`, `ActiveMQHints`.

These types which required reflection came from `javax.jms` (`04262a2`),
`org.apache.activemq` (`09f31abf`), and `org.springfoundation.jms` (`0340631`).

I made some effort to minimize the set of types to include. This minimization
was again performed by trial-and-error.

## Step 11. Testing on Different Platforms

I briefly tested my final commit, `a326402`, on a few different platform configurations.

- macOS Dev Laptop:
- macOS Dev Laptop + Docker + `run-dev-container.sh`
- Linux Dev Laptop
- Linux Freshly-Installed Dev VM

On each configuration, `samples/activemq` was built and tested with both JVM
execution (via `mvn package spring-boot:run`) and `native-image` execution (via
`./build.sh`).

Note that on each system I needed to run `mvn install` inside of
`spring-native-configuration/` in order to make the Maven plugin use my
revisions. (I haven't yet studied the Maven project setup to figure out why this
isn't automatic. Is this intentional? It's been a while since I've used Maven.
Is this conventional?)

In all cases here are the versions which I tested with (except inside of the
development container where GraalVM was given):

- macOS v11.5
- GraalVM v21.2.0 Java 11
- Linux Fedora 34.

I didn't check the Maven versions used on each system. But I suspect that they
varied.

Note that I had intended to test the development container on my Fedora 34
systems. However, because they use Podman as a drop-in replacement for Docker,
an incompatibility prevented this. Evidently, Podman does not support Docker's
`:delegated` volumes. The `run-dev-container.sh` script uses this feature.

## Step 12. Writing this Document

Finally, I drafted this document.

## Missing Feature: Automatic Reflection of Message Type

The overall goal of this project has been to move any manual "Spring-related"
native configuration out of the user's application and into generic and
automatic native configuration in Spring Native.

However, my sample application still has one important piece of manual native
configuration left: the custom message type [is manually marked
reflective][sample-reflect-config-json]. Message types should be made reflective
automatically.

In my very brief experience with this Spring Native, I have not yet discovered
an appropriate way to do this. (Making all observed types reflective would
obviously do the trick, but that would completely undermine the intension of
Spring Native.) All of the other types which I have needed to configure have
been a part of Spring or ActiveMQ or JMS. So, I have been able to statically
encode `@NativeHint`s which name them. However, for custom message types, some
sort of dynamic analysis is needed, and I don't know enough about Spring
Framework, Spring JMS, and Spring AOT to know how I should approach this.

Maybe the [`ComponentProcessors`][spring-native-ref-11-3-2] section of the
manual is pointing me in the direction of inspecting Spring to discover these
custom message types dynamically. But, I don't actually understand what is being
said here. I think that I don't have a good enough understanding of Spring to
understand.

Then again, maybe an analysis in `NativeConfiguration#computeHints(TypeSystem)`
is sufficiently powerful, its just that I don't yet understand Spring JMS and
the affordances of the `TypeSystem` API well enough yet.

## Poor Style: Use of Strings to Identify Types in `spring-native-configuration`

One obvious problem with the `@NativeHint`s which I have added to `JmsHints` and
`ActiveMQHints` is that they use Java string literal expressions to identify
relevant types. This differs from the style used throughout
`spring-native-configuration`: `.class` expressions are preferred to help
leverage the Java compiler in checking whether a named class exists.

My initial attempt to use `.class` expressions didn't work out, because the
`javac` invocation for `spring-native-configuration` couldn't find the relevant
types from `org.apache.activemq`, `javax.jms`, and `org.springframework.jms`.
The Spring Native reference's [contributions section][spring-native-ref-11-2]
mentions what to do in this case:

> It is possible that more dependencies may need to be added to the
> configuration project to allow the direct class references. That is OK, so
> long as you ensure that they are provided scope.

However, my initial attempt to add ["provided"][maven-guide-dependency-scope]
dependencies to `spring-native-configuration/pom.xml` didn't work. These types
still weren't found during compilation. I'm not sure why. I'd need to look at
this issue again more closely to figure it out.

## Questionable Design: Hint Activation Logic

A key design intention of Spring Native appears to be that native configuration
should only be added to `native-image` invocations when it is really needed. We
try to minimize unnecessary native configuration. For example, if a type doesn't
need reflective access in an application, then it shouldn't be given reflective
access. I suspect that this minimization can have important performance
benefits at both build-time and run-time.

Spring Native contributors are responsible for striving for and maintaining this
minimization. Thus, Spring Native contributors need to conditionally gate their
native configuration. Dynamic inspection of the user's application code is
needed to decide whether specific configuration should be enabled or disabled as
needed. (Of course, these analyses of application code can come with tradeoffs.
We probably don't want these to be ridiculously expensive or complicated
analyses.)

By my understanding so far, there are a few main ways for Spring Native
contributors to condition native configuration:

1. `@NativeHint` trigger types
2. By overriding `NativeConfiguration#isValid()`.
3. By overriding `NativeConfiguration#computeHints(TypeSystem)`
4. By implementing the Processor types described in the Spring Native
reference [here][spring-native-ref-11-3-2].

Of these, I have so-far only experimented with and studied the first three. In
my solution, I have relied upon the second approach. (This could have been
replaced with the first approach, and the result would have been slightly
simpler, but that would require use of `.class` expressions of dependencies that
aren't yet included. See the preceeding section for some context on why.)

But regardless of what method I use to enable native configuration items, there
is a more important problem. I don't really understand the domain well enough to
know whether I have chosen *appropriate* conditions. Simply checking for the
presence of some type may lead to errors, both false negatives and false
positives.

Intuitively, it seems like the condition that I really want to use is something
that we expect to uniquely come from the `spring-boot-starter-activemq`.
However, I'm not sure what this condition would be.

Before merging my code, it seems prudent that I ask someone with more experience
designing native configuration code what conditions I should use.

## Overall Impression

This small project was a fun learning experience. I needed to face a few
unfamiliar technologies alone. Fortunately, I had a few things on my side:
Spring Native's good documentation, a clear codebase, lots of examples, and my
previous familiarity hacking on Java tooling. I found that I was able to quickly
dive in to this codebase, become productive, and mostly complete this
assignment. Throughout this process, I always had a clear next step or goal, and
I was lucky that I didn't run into many speed bumps along the way. Things mostly
just worked.

Thanks for the opportunity to work on this small project. I look forward to the
possibility of joining you in working on Spring Native and bringing its promise
to a larger audience.

---

[dwtj-fork]: https://github.com/dwtj/spring-native
[issue-438]: https://github.com/spring-projects-experimental/spring-native/issues/438
[messaging-with-jms]: https://spring.io/guides/gs/messaging-jms/
[spring-native-ref]: https://docs.spring.io/spring-native/docs/0.10.2/reference/htmlsingle/
[tracing-agent]: https://www.graalvm.org/reference-manual/native-image/Agent/
[spring-native-ref-11-5-1]: https://docs.spring.io/spring-native/docs/0.10.2/reference/htmlsingle/#_comparing_images
[dynamic-proxy-classes]: https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html
[spring-native-ref-11-2]: https://docs.spring.io/spring-native/docs/0.10.2/reference/htmlsingle/#how-to-contribute-new-hints
[spring-aot-debug-log-line]: https://github.com/spring-projects-experimental/spring-native/blob/24524179a49bcb3e35906526e2ee2d760470193d/spring-aot/src/main/java/org/springframework/nativex/type/SpringConfiguration.java#L50
[spring-native-ref-11-3-2]: https://docs.spring.io/spring-native/docs/0.10.2/reference/htmlsingle/#_taking_more_control_via_processors
[sample-reflect-config-json]: https://github.com/dwtj/spring-native/blob/a32640276128e44cfdf973700b92ee0b2b160641/samples/activemq/src/main/resources/META-INF/native-image/com.example/activemq/reflect-config.json#L3
[maven-guide-dependency-scope]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#dependency-scope
